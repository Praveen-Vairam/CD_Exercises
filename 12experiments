Ex. 1: Write a simple calculator program in C/C++/JAVA
Features of the calculator:
• Take input from standard input.
• On each line an arithmetic expression can be given in the standard format and the
calculator
• must print the o/p after that.
• The calculator should exit, when the user enters the Ctrl^D (eof) character.
• Supported operators: +, -, *, /, ^, and ().
Procedure for simple calculator:
1. Read a line of input
2. If input is Ctrl^D terminate the program
3. If the expression is not balanced for parenthesis report error and go to step 1
4. Convert the expression into post-fix notation
5. Scan through the post-fix expression and push the operands into the stack in the
order they appear
6. When any operator is encountered pop the top two stack elements (operands) and
execute the operation
7. Push the result on to the stack
8. Print the result and got to step 1
Procedure for post-fix conversion:
1. Scan the expression from left to right
2. If the scanned character is operand place it in postfix expression
3. If the scanned character is an operand
a. If the precedence and associativity of the scanned operator is larger than the one
in the stack then push it onto the stack.
b. Else pop all the operators from the stack, which are greater than or equal to in
precedence and place it in postfix expression and push the scanned operator into the
stack. Popping should be stopped if a parenthesis is encountered.
4. If the scanned character is a ‘(‘ push it into the stack
5. If the scanned character is a ‘)’, pop the stack and output it until a ‘(‘ is
encountered, and discard both the parenthesis.
6. Repeat steps 2-5 until the infix expression is scanned.
7. Once the scanning is over, pop the stack and add the operators in the postfix
expression until it is not empty.
8. Return the postfix expression.

Procedure for Balancing Symbols:
1. Traverse the expression from left to right.
a. If the current character is a starting bracket, then push it to stack
b. If the current character is a closing bracket, then pop from stack and if the poppedcharacter
is not matching starting bracket, return “not balanced”.
2. If there is some starting bracket left in stack then return “not balanced”
3. Return balanced
Example run of the program:
Input: 2 + 3 * 5
Output: 17
Input 2: (2 + 3) * 5
Output 2: 25
Input 3: 30 / 5 / 2
Output 3: 3
Input 4: 2 ^ 3 ^ 2
Output 4: 64
Input 5: (2 ^ 3) ^ 2
Output 5: 36

Ex. 2: Write a program Using FLEX
Flex is a scanner generator tool for lexical analysis, which is based on finite state
machine (FSM). The input is a set of regular expressions, and the output is the code to
implement the scanner according to the input rules.
To implement a scanner for calculator, we can write the file “cal1.l” as below:
/* this is only for scanner, not link with parser yet */
%{
int lineNum = 0;
%}
%%
"(" { printf("(\n"); }
")" { printf(")\n"); }
"+" { printf("+\n"); }
"" { printf("\n"); }
\n { lineNum++; }
[ \t]+ { }
[0-9]+ { printf("%s\n", yytext); }
%%
int yywrap() {
return 1;
}
int main () {
yylex();
return 0;
}
Here is the Makefile used to build the scanner:
p1: lex.yy.o
gcc -g -o p1 lex.yy.o
lex.yy.o: cal1.l
flex cal1.l; gcc -g -c lex.yy.c
clean:
rm -f p1 *.o lex.yy.c
Simple calculator program in bison
//yacc file
#include&lt;stdio.h&gt;
int regs[26];
int base;
%}

%start list
%union { int a; }
%token DIGIT LETTER
%left &#39;|&#39;
%left &#39;&amp;&#39;
%left &#39;+&#39; &#39;-&#39;
%left &#39;*&#39; &#39;/&#39; &#39;%&#39;
%left UMINUS /*supplies precedence for unary minus */
%% /* beginning of rules section */
list: /*empty */
|
list stat &#39;\n&#39;
|
list error &#39;\n&#39;
{
yyerrok;
}
;
stat: expr
{
printf(&quot;%d\n&quot;,$1);
}
|
LETTER &#39;=&#39; expr
{
regs[$1.a] = $3.a;
};

Ex. 3 : Implementation of scanner by specifying Regular Expressions
Procedure:
1. Place the following files in a folder minijava.html, P1.tab.h, P1.l and a sample
input file
(Factorial.java).
2. flex P1.l
3. gcc lex.yy.c -o P1
4. P1
5. Give = if as input
Output: = number (number is symbol table id of =)
if number (number is symbol table id of if)
6. Fill in the code that you have been asked to include in P1.l
7. flex P1.l
8. gcc lex.yy.c -o P1
9. P1 < Factorial.java
10. All tokens generated by the parser will be placed in the output
The content for minijava.html:
Goal ::= MainClass ( TypeDeclaration )* <EOF>
MainClass ::= "class" Identifier "{" "public" "static" "void" "main" "(" "String" "["
"]" Identifier ")" "{" PrintStatement "}" "}"
TypeDeclaration ::= ClassDeclaration
| ClassExtendsDeclaration
ClassDeclaration ::= "class" Identifier "{" ( VarDeclaration )* ( MethodDeclaration
)* "}"
ClassExtendsDeclaration ::= "class" Identifier "extends" Identifier "{" (
VarDeclaration )*
( MethodDeclaration )* "}"
VarDeclaration ::= Type Identifier ";"
MethodDeclaration ::= "public" Type Identifier "(" ( FormalParameterList )? ")" "{"
( VarDeclaration )*
( Statement )* "return" Expression ";" "}"
FormalParameterList ::= FormalParameter ( FormalParameterRest )*
FormalParameter ::= Type Identifier
FormalParameterRest ::= "," FormalParameter
Type ::= ArrayType
| BooleanType
| IntegerType
| Identifier
ArrayType ::= "int" "[" "]"
BooleanType ::= "boolean"
IntegerType ::= "int"
Statement ::= Block
| AssignmentStatement 
| ArrayAssignmentStatement
| IfStatement
| WhileStatement
| PrintStatement
Block ::= "{" ( Statement )* "}"
AssignmentStatement ::= Identifier "=" Expression ";"
ArrayAssignmentStatement ::= Identifier "[" Expression "]" "=" Expression ";"
IfStatement ::= "if" "(" Expression ")" Statement "else" Statement
WhileStatement ::= "while" "(" Expression ")" Statement
PrintStatement ::= "System.out.println" "(" Expression ")" ";"
Expression ::= AndExpression
| CompareExpression
| PlusExpression
| MinusExpression
| TimesExpression
| ArrayLookup
| ArrayLength
| MessageSend
| PrimaryExpression
AndExpression ::= PrimaryExpression "&" PrimaryExpression
CompareExpression ::= PrimaryExpression "<" PrimaryExpression
PlusExpression ::= PrimaryExpression "+" PrimaryExpression
MinusExpression ::= PrimaryExpression "-" PrimaryExpression
TimesExpression ::= PrimaryExpression "*" PrimaryExpression
ArrayLookup ::= PrimaryExpression "[" PrimaryExpression "]"
ArrayLength ::= PrimaryExpression "." "length"
MessageSend ::= PrimaryExpression "." Identifier "(" ( ExpressionList )? ")"
ExpressionList ::= Expression ( ExpressionRest )*
ExpressionRest ::= "," Expression
PrimaryExpression ::= IntegerLiteral
| TrueLiteral
| FalseLiteral
| Identifier
| ThisExpression
| ArrayAllocationExpression
| AllocationExpression
| NotExpression
| BracketExpression
IntegerLiteral ::= <INTEGER_LITERAL>
TrueLiteral ::= "true"
FalseLiteral ::= "false"
Identifier ::= <IDENTIFIER>
ThisExpression ::= "this"
ArrayAllocationExpression ::= "new" "int" "[" Expression "]"
AllocationExpression ::= "new" Identifier "(" ")"
NotExpression ::= "!" Expression
BracketExpression ::= "(" Expression ")"
The content for P1.tab.h
/* A Bison parser, made by GNU Bison 2.5. */
/* Bison interface for Yacc-like parsers in C
Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>. */
/* As a special exception, you may create a larger work that contains
part or all of the Bison parser skeleton and distribute that work
under terms of your choice, so long as that work isn't itself a
parser generator using the skeleton or a modified version thereof
as a parser skeleton. Alternatively, if you modify or redistribute
the parser skeleton itself, you may (at your option) remove this
special exception, which will cause the skeleton and the resulting
Bison output files to be licensed under the GNU General Public
License without this special exception.
This special exception was added by the Free Software Foundation in
version 2.2 of Bison. */
/* Tokens. */
#ifndef YYTOKENTYPE
# define YYTOKENTYPE
/* Put the tokens into the symbol table, so that GDB and other debuggers
know about them. */
enum yytokentype {
HASHDEFINE = 258,
NOT = 259,
CURLY_OPEN = 260,
CURLY_CLOSE = 261,
PAR_OPEN = 262,
PAR_CLOSE = 263,
11
SQR_CLOSE = 264,
IF = 265,
WHILE = 266,
CLASS = 267,
PUBLIC = 268,
STATIC = 269,
VOID = 270,
MAIN = 271,
STR = 272,
PRINTLN = 273,
EXTENDS = 274,
THIS = 275,
NEW = 276,
SEMI_COLON = 277,
COMMA = 278,
LENGTH = 279,
TRUE = 280,
FALSE = 281,
NUMBER = 282,
RET = 283,
BOOL = 285,
INT = 286,
IDENTIFIER = 287,
ADD = 288,
SUB = 289,
MUL = 290,
DIV = 291,
MOD = 292,
BIT_AND = 293,
LESSTHAN = 294,
SQR_OPEN = 295,
DOT = 296,
ASSIGNMENT = 297,
ELSE = 298,
lab1 = 299,
newlabel = 300,
label = 301
};
#endif
#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
typedef union YYSTYPE
{
/* Line 2068 of yacc.c */
#line 25 "P1.y"
12
char* str;
/* Line 2068 of yacc.c */
#line 102 "P1.tab.h"
} YYSTYPE;
# define YYSTYPE_IS_TRIVIAL 1
# define yystype YYSTYPE /* obsolescent; will be withdrawn */
# define YYSTYPE_IS_DECLARED 1
#endif
extern YYSTYPE yylval;
Template of the lex (P1.l) file with code for one operator and one keyword.
%{
#include "P1.tab.h"
#include<stdio.h>
#include<stdlib.h>
%}
%%
/* Write code to ignore empty spaces and newlines. */
/* Write code to ignore comments (single line and multiline). */
/* Write code to scan all the operators, paranthesis etc. Example shown for
assignment. */
"=" {char* str=yytext;printf ("%s %d\n", str, ASSIGNMENT);}
/* Write code to scan all the keywords. Example shown for if */
"if" {char* str=yytext;printf ("%s %d\n", str, IF);}
* Write code to scan all the punctuations. */
/* Write code to scan numbers and identifiers. */
/* Write code to throw error if you encounter any invalid token. */
%%
int main(){
yylex();
}
int yywrap(){}
The content for Factorial.java
class Factorial{
public static void main(String[] a){
System.out.println(new Fac().ComputeFac((10)));
}
}
class Fac { // Test


public int ComputeFac(int num){
int num_aux ;
if (num < 2)
num_aux = 1 ;
else

num_aux = num * (this.ComputeFac(num-1)) ;
return num_aux ;
}}
Ex. 4: Write a program using BISON.Simple calculator program in bison
//yacc file #include&lt;stdio.h&gt;int regs[26];
int base;
%}
%start list
%union { int a; }
%token DIGIT LETTER
%left &#39;|&#39;
%left &#39;&amp;&#39;
%left &#39;+&#39; &#39;-&#39;
%left &#39;*&#39; &#39;/&#39; &#39;%&#39;
%left UMINUS /*supplies precedence for unary minus */
%% /* beginning of rules section */
list: /*empty */
|
list stat &#39;\n&#39;
|
list error &#39;\n&#39;
{
yyerrok;
}
;
stat: expr
{
printf(&quot;%d\n&quot;,$1);
}
|
LETTER &#39;=&#39; expr
{
regs[$1.a] = $3.a;
}
;
expr: &#39;(&#39; expr &#39;)&#39;
{
$$ = $2;
}
|
expr &#39;*&#39; expr
{
$$.a = $1.a * $3.a;
}
|
expr &#39;/&#39; expr
{
$$.a = $1.a / $3.a;
}
|
expr &#39;%&#39; expr
{
$$.a = $1.a % $3.a;
}
|
expr &#39;+&#39; expr
{
$$.a = $1.a + $3.a;
}
|
expr &#39;-&#39; expr
{
$$.a = $1.a - $3.a;
}
|
expr &#39;&amp;&#39; expr
{
$$.a = $1.a &amp; $3.a;
}
|
expr &#39;|&#39; expr
{
$$.a = $1.a | $3.a;
}
|
&#39;-&#39; expr %prec UMINUS
{
$$.a = -$2.a;
}
|
LETTER
{
$$.a = regs[$1.a];
}
|
number
;
number: DIGIT
{
$$ = $1;
base = ($1.a==0) ? 8 : 10;
} |
number DIGIT
{
$$.a = base * $1.a + $2.a;
}
;
%%
main()
{
return(yyparse());
}
yyerror(s)
char *s;
{
fprintf(stderr, &quot;%s\n&quot;,s);
}
yywrap()
{
return(1);
}
LEX FILE
#include &lt;stdio.h&gt;
#include &quot;y.tab.h&quot;
int c;
%}
%%
&quot; &quot; ;
[a-z] {
c = yytext[0];
yylval.a = c - &#39;a&#39;;
return(LETTER);
}
[0-9] {
c = yytext[0];
yylval.a = c - &#39;0&#39;;
return(DIGIT);
}
[^a-z0-9\b] {
c = yytext[0];
return(c);
}
%%
1) Create the calc.yacc file
2) Create the calc.lex file
3) Run the following commands:
yacc -d calc.yacc
lex -d calc.lex
cc y.tab.c lex.yy.c
./a.out
OUTPUT:
5+4
9

Ex. 5. Write a program for Top-Down Parsing - predictive parsing table 

Removal of left factoring public static List<String> left Factor(List<String> grammar) | List<String> newGrammar new ArrayList();

herate over each non-terminal in the grammar for (String production: grammar) ( String[] parts production.split(" String non Terminal = parts(0).trim(); 20

String alternatives = parts[1] trim().split("/")

Find the common prefix among alternatives String commonPrefix = find CommonPrefix(alternatives),

If there is a common prefix, perform left factoring if (commonPrefix.isEmpty()) {

StringBuilder sb = new StringBuilder(); sb.append(non Terminal).append(">"Lappend(commonPrefix).append("

"append(non Termunal).append(""); newGrammar.add(sb.toString());

StringBuilder sh2 new StringBuilder();

for (String alt alternatives) | if (alt.startsWith(commonPrefix)) [

sb2.append(alt.substring(comumonPrefix.length()).trim()); sh2.append("")

sb2.append("c");

newGrammar.add(nonTerminal+sh2.toString(1k else If no comanon prefix, keep the production as is newGrammat.add(productine);

1

return new-Grammar.

Parse table creation

public class TupDownParser

public static void main(String[] args) { Example grammar: 5A, AAA

Map String. Set<String>> firstSets new HashMap(); Map String. Set String>> followSets new HashMap;

Construct FIRST sets

firstSets.put("S", new HashSet firstSets put("A", new HashSet());

firstSets.get("$").add("a");

firstSets get("A").add("a");

FirstSets.get("A").add("");

Construct FOLLOW sets

follow/Sets.put("S", new HashSet) followSets.put("A", new HashSet()); followSets.get("S") add("$"),

FollowSets.get("A").add("S"); followSets.get("A").add("a");

Construct parse table

Map<String, Map<String, String>> parse Table new HashMap();

purse Table.put("S", new HashMap()); parse Table pur("A", new HashMap<>());

parse Table get("S").put("a". "A"). parse Table get("A") put("a", "aA");

purse Table get("A") .put("$", "")

Print FIRST seta

System.out.println("FIRST sets:"); for (Map Entry<String. Set<String>> entry firstSets.entrySet())

System.out.println(eatry getKey()+"+entry.getValue());

Print FOLLOW sets System.out.println("\nFOLLOW sets");

for (Map EntryString. Set String entry: followSets.entrySet(1) [ 1 System.out.println(entry.getKey()++ entry.gutValue());

Print parse table

System.out.println("\nParse Talle:");

for (Map Entry String. Map-String, String entry: parseTable.entrySet()) |

String non Terminal entry.getKey(); Map<String, String> actions entry.getValue();

System.out.println("Non-Terminal:"+nonTerminal); System.out.println("Actions: actions);

EXPRESSION GRAMMAR

EE+T

E>T

TT F

TOF

F(E)

Foid

OUTPUT

PARSE TABLE

Ex. 6: Write a program for Bottom-Up Parsing - SLR Parsing

import java.util.*; class SLRParser

private final List<String> grammar, private final Map<Integer, Map<String, String actionTable;

private final Map<Integer, Map<String, Integer>> goToTable,

private final Stack<Integer> stateStack:

private final Stack String symbolStack;

private final List<String> input

public SLRParser(List<String> grammar, Map<Integer, Map<String, String> action Table, Map Integer, Map<String, Integer>> goToTable. List<String> input)

1

this grammar grammar:

this action Table action Table; this goToTable goToTable; this.input input: this stateStack new Stack();

this symbolStack= Stack

public boolean parse() (

stateStack push(0); int inputIndex = 0;

while (inputIndex <input.size()) {

int currentState stateStack.peek();

24

String currentSymbol input.get(inputIndex)

if (action Table.containsKey(currentState) &&

action Table.get(currentState).containsKey(currentSymbol )) ( String action actionTable get(currentState).get(currentSymbol);

if (action.startsWith("") {

int nextState = Integer.parseInt(action.substring(1)) stateStack pushtnextState); symbolStack.push(currentSymbol); int productionIndes Integer.parseInt(action.substring(1)); String production grammar.get(productionIndex); for (int i=0; i<len; i++) { stateStack.pop(); stateStack.push(goToTable.get(currentState).get(non Terminal));

inputIndex++; else if (action startsWith("r")) {

Stringil parts production.split("") String left Purt parts[0].trim();

String rightPut paris[1].trim(); int len = rightPart.split("").length;

symbolStack.pop();

curemState stateStack.peek(); String non Terminal leftPart:

symbolStack.push(nonTerminal); else if (action.equals("accept"))

return true;

}else{

No valid action in action table, parsing fails

return false;

1

1

No more input symbols, parsing fails

return false;

public class Main

public static void main(String[] args) |

Example granuar

List String grammar Arrays.asList(

"SE

EE-T

"ET",

Tid

Example action table

Map Integer, Map<String, String> action Table new HashMap-> Map<String, String action new HashMap();

action).put("id", "s3");

action Table.put(0, action)); Map<String, String> actioni new HashMap()

action1.put("+", "4"); action Table put(1, action);

Map<String, String action3 new HashMap(); action3.put("5", "accept");

action Table.pun3, action3);

Map<String, String> action4 new HashMap

action4.put("id", "3"); action Table.put(4, action4);

Example go-to table

Map<Integer, Map<String, Integer>> goToTable = new HashMap);

Map<String, Integer goToll new HashMap

guTo0.put("E", 1);

goToTable.put(0, goTol));

Map<String, Integer> goTol = new HashMap();

goTol.put(T. 2

goToTable put(1, goTol); Example input

List<String>inputArrays.asList("id ", "+", "id", "S").

SLRParser porser new SLRParser(grammar, action Table, goToTable, input);

boolean resalt parser.parse();

if (result) [

System.out.println("Input string accepted by grammar."). 1 else

System.out.println("Input string rejected by grammar.");

OUTPUT: Enter input word: id id

The string is accepted

Ex. 8: Write a program to traverse syntax trees and perform action arithmetic
operations

Sample Code

class TreeNode |

String value; TreeNode left;

TreeNode right;

TreeNode(String value) | this, value value; this.left = null; this.right = null;

public class Syntax Tree Traversal |

public static int traverseAndCalculate(TreeNode node) ( if (node null) {

return 0;


if (node.left = null && node.right == null) ( return Integer.parseInt(node.value);

int left Value traverseAndCalculate(node.left); int rightValue traverseAndCalculate(node.right);

switch (node.value) [

case "+":

retum left Value + rightValue;

case "-":

retum left Value-right Value:

case

return left Value rightValue;

case "": if (right Value==0) |

throw new ArithmeticException("Division by zero");

default:

retum left Value/rightValue;

throw new IllegalArgumentException("Invalid operator: " + node.value);

public static void main(String[] args) (

// Example syntax tree: 3+ (52) TreeNode root new TreeNode("+"); root.left new TreeNode("3"); root.right = new TreeNode("*"); root.right.left = new TreeNode("5");

root.right.right = new TreeNode("2");

//Perform traversal and calculation

int result traverseAndCalculate(root); System.out.println("Result:"result);

Implemented a method traverse and calculate to recursively traverse the syntax tree an

perform arithmetic operations. In the main method, created an example syntax tre

representing the expression 3+ (52), reverse the tree, and print the result.
 Ex. 10: Code Generation Introduction to MIPS Assembly language

Sample Code:
.data
num1: .word 10
num2: .word 5
.text
main:
# load num1 into $a0
lw $a0, num1
# load num2 into $a1
lw $a1, num2
# add num1 and num2
add $v0, $a0, $a1
# print result
li $v0, 1 # syscall code for print_int
syscall
# exit program
li $v0, 10 # syscall code for exit
syscall
Output: 15

Ex. 11: Write a program to generate machine code for a simple statement

Sample Code:
import java.io.FileOutputStream;
import java.io.IOException;
public class GenerateMachineCode {
public static void main(String[] args) throws IOException {
// Create a byte array to store the machine code
byte[] machineCode = new byte[4];
// Set the opcode for the MIPS instruction in the byte array
machineCode[0] = (byte) 0x0;
// Set the source register for the first operand in the byte array
machineCode[1] = (byte) 0x0;
// Set the source register for the second operand in the byte array
machineCode[2] = (byte) 0x80;
// Set the destination register in the byte array
machineCode[3] = (byte) 0x21;
// Write the machine code to a file
try (FileOutputStream fos = new FileOutputStream(“machine_code.bin”)){
fos.write(machineCode);
}
catch (IOException e) {
e.printStackTrace();
}
}
}

Ex. 12: Write a program to generate machine code for an indexed assignment statement

Sample Code:
import java.io.FileOutputStream;
import java.io.IOException;
public class GenerateMachineCodeIndexedAssignment {
public static void main(String[] args) throws IOException {
// Create a byte array to store the machine code
byte[] machineCode = new byte[6];
// Set the opcode for the MIPS instruction in the byte array
machineCode[0] = (byte) 0x2b;
// Set the source register in the byte array
machineCode[1] = (byte) 0x04;
// Set the base register in the byte array
machineCode[2] = (byte) 0x00;
// Set the offset in the byte array
machineCode[3] = (byte) 0x00;
machineCode[4] = (byte) 0x00;
machineCode[5] = (byte) 0x18;
// Write the machine code to a file
try (FileOutputStream fos = new FileOutputStream("machine_code.bin")) {
fos.write(machineCode);
} catch (IOException e) {
e.printStackTrace();
}
}
}
